# SVD 손실 압축과 고유값 분해의 관계

SVD 압축의 핵심은 **"이미지의 '핵심적인 정보'와 '사소한 디테일'을 분리한 뒤, 핵심 정보만 남겨서 데이터를 압축하는 것"** 입니다. 그리고 무엇이 핵심적인 정보인지를 판단하는 기준이 바로 고유값의 개념에서 나옵니다.


## 1. SVD 압축의 핵심 원리: '중요도' 순으로 분해하기

모든 행렬(이미지) $A$는 SVD를 통해 다음과 같이 분해할 수 있습니다.

$$ A = U\Sigma V^T $$

이를 풀어서 쓰면, 이미지는 여러 개의 **'레이어(layer)'** 가 겹쳐진 형태로 표현할 수 있습니다.

$$
\text{원본 이미지}(A) = \sigma_1(\vec{u}_1 \otimes \vec{v}_1) + \sigma_2(\vec{u}_2 \otimes \vec{v}_2) + \sigma_3(\vec{u}_3 \otimes \vec{v}_3) + \dots
$$
*($\otimes$는 외적(outer product)을 의미하며, 두 벡터로 하나의 행렬(이미지 레이어)을 만드는 연산입니다)*

* **$\sigma_1, \sigma_2, \dots$ (특이값, Singular Values)**: 각 레이어의 **'중요도' 또는 '에너지'** 를 의미합니다. SVD는 이 값들을 큰 순서대로 정렬해 줍니다. 즉, $\sigma_1$이 가장 중요한 정보를, $\sigma_2$가 그다음으로 중요한 정보를 담고 있습니다.
* **$\vec{u}_i, \vec{v}_i$ (특이벡터, Singular Vectors)**: 이미지를 구성하는 **'핵심 패턴' 또는 '기본 형태'** 를 담고 있는 직교 기저 벡터들입니다.

**손실 압축(Lossy Compression)** 은 바로 이 지점에서 일어납니다. 원본 이미지를 완벽하게 복원하려면 모든 레이어를 더해야 하지만, 만약 우리가 **가장 중요한 상위 $k$개의 레이어만 골라서 더하면 어떻게 될까요?**

$$
\text{압축 이미지}(A_k) = \sum_{i=1}^{k} \sigma_i(\vec{u}_i \otimes \vec{v}_i)
$$

이것이 바로 제공된 Python 코드의 `for i in range(k):` 루프가 하는 일입니다. `k`가 작을수록 더 많은 디테일(중요도가 낮은 레이어)을 버리므로 압축률은 높아지지만 화질은 저하됩니다.


## 2. 고유값 분해(Eigendecomposition)와의 연결고리

그렇다면 "무엇이 중요하고 무엇이 사소한가?"를 어떻게 알 수 있을까요? 그 답이 바로 고유값에 있습니다.

이전에 설명했듯이, 행렬 $A$의 **특이값($\sigma_i$)** 은 행렬 $A^TA$의 **고유값($\lambda_i$)의 제곱근**($\sigma_i = \sqrt{\lambda_i}$)입니다.

> **특이값이 크다는 것은, 그에 해당하는 고유값도 크다는 의미입니다.**

고유값($\lambda$)은 해당 고유벡터(eigenvector) 방향으로 데이터가 얼마나 큰 분산(variance)이나 에너지를 갖는지를 나타내는 척도입니다. 즉, **고유값이 클수록 그 방향이 데이터의 '핵심적인 특징'을 더 많이 설명한다**는 뜻입니다.

따라서 SVD를 이용한 이미지 압축 전략은,

> **"가장 큰 고유값들에 해당하는, 가장 중요한 '고유 패턴(Eigen-patterns)'들($\vec{u}_i, \vec{v}_i$)만 $k$개 남기고, 중요하지 않은 나머지는 버리는 것"**

이라고 할 수 있습니다. SVD는 고유값 분해의 개념을 일반적인 행렬에 적용하여, 데이터의 '핵심 성분'을 중요도 순으로 추출하는 매우 강력한 방법입니다.


## 3. Python 코드 해설

* **`U, singular_values, Vt = np.linalg.svd(img_array)`**: 이미지를 행렬 $A$로 보고, 이를 핵심 패턴($U, V^T$)과 중요도(`singular_values`)로 분해합니다.
* **`for i in range(k): ...`**: 중요도가 높은 상위 $k$개의 (중요도 $\times$ 패턴) 레이어만 골라서 더해 압축된 이미지를 재구성합니다. `k`가 클수록 더 많은 레이어를 사용하여 원본에 가까워집니다.
* **`compression_ratio`**: 원본 이미지는 모든 픽셀($m \times n$) 정보를 저장해야 하지만, 압축된 이미지는 $k$개의 '레시피'($k$개의 $\sigma_i$, $\vec{u}_i$, $\vec{v}_i$)만 저장하면 되므로 데이터 크기가 줄어듭니다. 저장해야 할 데이터는 대략 $k \times (m+n+1)$ 입니다.