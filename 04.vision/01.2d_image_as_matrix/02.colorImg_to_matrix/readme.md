# Index 

8. 컬러 이미지 -> R,G,B 2차원 matrix
9. convolution 연산을 통한 이미지에 필터 입히기 
10. HSV 
11. 이진화(binarization)


# step8. color 2d image -> matrix -> 더 붉게 만들거나, 더 푸르게 만들기

## 8-1. 이번엔 각 픽셀이 단일값이 아닌 rgb(?,?,?) 값이다.
흑백사진엔 각 픽셀당 0~255사이의 숫자였는데,\
컬러는 픽셀당 rgb(?,?,?)이다.

```python
img = Image.open(image_path).convert('RGB')

# 그 다음엔 각 픽셀에서 R, G, B 값을 뽑아서 각각 다른 매트릭스(2차원 리스트)에 저장한다.
# matrix_r, matrix_g, matrix_b 각각 이미지 높이x너비 크기의 2차원 리스트
for y in range(height):
    for x in range(width):
        r, g, b = img.getpixel((x, y)) # 요기서 (R,G,B) 튜플이 나옴
        matrix_r[y][x] = r
        matrix_g[y][x] = g
        matrix_b[y][x] = b
```
결국 R 성분만 모아놓은 매트릭스, G 성분만 모아놓은 매트릭스, B 성분만 모아놓은 매트릭스, 이렇게 총 3개가 나오는 거임


## 8-2. 색상, RGB는 채널이라고도 한다.
컬러 이미지가 "가로 x 세로 x 채널 수"의 3차원 행렬이라고 할 때, 이 **"채널(Channel)"** 은 쉽게 말해 **색상 정보를 담는 여러 개의 층(layer)**

- 흑백 이미지 (Grayscale Image):
    - 얘는 채널이 1개입니다. 각 픽셀은 오직 밝기 정보(0=검정, 255=흰색, 그 사이는 회색조)만을 가집니다. 그래서 이미지는 그냥 2차원 행렬 (가로 x 세로)로 표현돼요.
- 컬러 이미지 (Color Image - 예: RGB):
    - 가장 흔한 RGB 컬러 이미지는 채널이 3개입니다.
        1. R 채널: 이미지의 각 픽셀 위치에서 빨간색(Red) 성분이 얼마나 강한지를 나타내는 2차원 행렬입니다.
        2. G 채널: 이미지의 각 픽셀 위치에서 초록색(Green) 성분이 얼마나 강한지를 나타내는 2차원 행렬입니다.
        3. B 채널: 이미지의 각 픽셀 위치에서 파란색(Blue) 성분이 얼마나 강한지를 나타내는 2차원 행렬입니다.

이 세 개의 2차원 행렬(R, G, B 각각 가로x세로 크기)이 합쳐져서 우리가 보는 하나의 컬러 이미지를 만드는 거예요. 마치 투명한 빨간색 필름, 초록색 필름, 파란색 필름을 겹쳐서 다양한 색을 만들어내는 것과 비슷합니다.

그래서 특정 픽셀 (예: (10, 20) 위치)의 색상 값은 (R값, G값, B값) 이렇게 세 개의 숫자로 표현되고, 전체 이미지는 (가로 픽셀 수) x (세로 픽셀 수) x 3 형태의 3차원 행렬이 되는 겁니다. OpenCV에서는 보통 이 3을 (B, G, R) 순서로 다룹니다.


Q. R채널이 왜 2차원 행렬이라는거지? 0~255값 중 하나면 scalar잖아?\
A. 1 pixel에 R값을 말하는게 아니라, R 채널은 10x10 image에 100개의 픽셀에 R값을 나타내는 것.\
R이 70의 값이라고 치면,\
[0, 70], [1, 70], [2, 70], [3, 70], ...

이런식으로 간다는거지. 이게 2차원 행렬인거고

$$
\begin{bmatrix} R1 & R2 \ R3 & R4 \ R5 & R6 
\end{bmatrix}
$$
마찬가지로 G,B 도 2차원 행렬로 되어있고,\
연산 끝난 후, 맨 마지막에 R,G,B 2차원 행렬을 합쳐서 색 표현하는 것.

---
다른 설명 

10x10 픽셀 컬러 이미지가 있다면:
- R 채널 행렬 (matrix_r): 10x10 크기의 2차원 행렬입니다. 각 위치 (y, x)에는 해당 픽셀의 빨간색(Red) 강도 (0~255 사이의 숫자 하나)가 들어갑니다.
    - 예: matrix_r[y][x] = R값 (스칼라)
- G 채널 행렬 (matrix_g): 동일하게 10x10 크기이며, 각 위치에 초록색(Green) 강도 (0~255 숫자 하나)가 들어갑니다.
- B 채널 행렬 (matrix_b): 역시 10x10 크기이며, 각 위치에 파란색(Blue) 강도 (0~255 숫자 하나)가 들어갑니다.

그래서 이미지의 특정 픽셀 (y, x)의 색상은 (matrix_r[y][x], matrix_g[y][x], matrix_b[y][x])라는 세 개의 숫자(벡터)로 표현됩니다.


## 8-3. 분리된 R,G,B matrix에 행렬연산하기

특정 색깔(ex. red)만 스칼라 값(숫자) 곱하면 더 붉으스름해짐 

```python
# 예: 빨간색 채널 매트릭스에 1.5를 곱함
scaled_channel_r = scale_channel(matrix_r, 1.5)
```

아니면 뭐 G값이랑 B값이랑 swap도 가능. 색깔이 기괴하게 변함 
```python
swap_rb_channels(r_orig, g_orig, b_orig)
```

아니면 색깔 -> 흑백이미지로 바꿀 때, R,G,B마다 각각 특정 숫자값(국룰)을 곱해주면 greyscale 값이 된다.
$$ Y = 0.299 \times R + 0.587 \times G + 0.114 \times B $$

$Y$가 바로 흑백 이미지의 밝기 값(그레이스케일 값)이다. 각 픽셀의 R, G, B 값에다가 저 가중치들 곱해서 싹 더하면 됨.

```python 
gray_value = (0.299 * r_matrix[y][x] +
              0.587 * g_matrix[y][x] +
              0.114 * b_matrix[y][x])
grayscale_matrix[y][x] = max(0, min(255, int(round(gray_value))))
```

이거 잘 보면, 각 픽셀의 컬러 벡터 $P = \begin{bmatrix} R \ G \ B \end{bmatrix}$ 와 가중치 벡터 $W = \begin{bmatrix} 0.299 \ 0.587 \ 0.114 \end{bmatrix}$ 의 내적(dot product) $Y = W^T P$ (또는 $P^T W$) 이랑 똑같은 거임.



## 8-4. 각 픽셀에 R,G,B값을 합쳐서 색깔 표현 
```python
# 대충 이런 식으로 R, G, B 값을 가진 픽셀 리스트를 만듦
combined_image_data = []
for y in range(height):
    row_pixels = []
    for x in range(width):
        # 값 범위 0~255로 맞춰주는 거 중요! 안 그럼 짤 깨짐.
        r_val = max(0, min(255, int(round(matrix_r[y][x]))))
        g_val = max(0, min(255, int(round(matrix_g[y][x]))))
        b_val = max(0, min(255, int(round(matrix_b[y][x]))))
        row_pixels.append([r_val, g_val, b_val])
    combined_image_data.append(row_pixels)

plt.imshow(combined_image_data) # 요렇게 넘기면 컬러로 딱!
```
- 아까 R,G,B가 2차원 행렬이라는 설명했지? 각각 연산 끝났으니, 이제 합쳐서 색표현 하는 것.
- 핵심은 R, G, B 매트릭스에서 같은 위치 (y, x)의 값들을 뽑아 [r, g, b] 형태의 리스트로 만들고, 이걸 다시 전체 이미지 구조로 쌓는 거다.
- 그리고 연산하다 보면 픽셀 값이 255 넘어가거나 0보다 작아질 수 있는데, max(0, min(255, ...)) 이걸로 범위 안에 딱 가둬놔야 이미지가 정상적으로 보임 


# step9. image filering: convolution 연산을 통한

## 9-1. what 
이미지 필터도, 아까 step6,7 edge detection에서 했던, 특정 3x3 matrix 를 마련하고 이미지에 모든 픽셀을 for으로 돌면서 matrix multiplication 하는 원리는 똑같음.

다만, 이미지 필터 마다 저 3x3 matrix 안에 값이 다르겠지?

## 9-2. color image -> R,G,B 3개의 2차원 행렬로 분해
 * `matrix_r` (빨강 채널 행렬), `matrix_g` (초록 채널 행렬), `matrix_b` (파랑 채널 행렬)

 * **커널 (Kernel) 행렬**: 이게 필터의 핵심이다. 보통 3x3짜리 작은 행렬인데, 이놈 값에 따라 블러가 되기도 하고, 짤이 선명해지기도 하고, 이펙트가 먹여진다. 예를 들어, **샤프닝 커널**은 이렇게 생겼다:
    $$
    K_{sharpen} = \begin{bmatrix} 0 & -1 & 0 \\ -1 & 5 & -1 \\ 0 & -1 & 0 \end{bmatrix}
    $$
    (이 커널 쓰면 왠지 짤이 좀 더 쨍해 보임.)

## 9-3. 패딩(Padding): 짤 테두리 확장공사 🚧

컨볼루션 연산할 때 커널이 이미지 가장자리 픽셀에서도 계산을 하려면, 커널 크기만큼 이미지 바깥 영역이 필요하다. 근데 실제 이미지 바깥엔 데이터가 없잖아? 그래서 이미지 테두리에다가 임의의 값(보통 0)으로 한 줄 (또는 여러 줄) 덧대는 작업을 하는데, 이걸 **패딩(Padding)**이라고 한다.

* 3x3 커널을 쓰면 보통 1픽셀 두께로 패딩을 박는다.
* **왜 하냐고?** 이렇게 해야 필터링 후에도 이미지 크기가 원본이랑 똑같이 유지됨 (이걸 'same' 패딩이라고 부름. 안 하면 짤 크기 줄어든다).
* 10x10짜리 R 채널 행렬에 1픽셀 패딩하면 12x12짜리 R 채널 행렬 되는 거임. G, B도 마찬가지.

## 9-4. 컨볼루션(Convolution) 연산: for loop 돌면서 1픽셀 x kernel 한다(matrix multiplication)

이제 연산 파트다. 

패딩된 R, G, B 각 채널 행렬에다가 커널 행렬을 왼쪽 위부터 한 칸씩 옮겨가면서 계산을 하는 것. 

결과 이미지의 한 픽셀 값이 어떻게 나오는지 R 채널을 예로 들어보자.

결과 이미지의 특정 위치 $(y_{out}, x_{out})$의 R 값을 구한다고 치자.

1.  **패치(Patch) 뽑기**: 패딩된 R 채널 행렬에서, 현재 커널이 올라갈 자리 (결과 픽셀 $(y_{out}, x_{out})$에 해당)의 3x3 영역을 그대로 떠온다. 이걸 **패치**라고 부르자.
    * 예: 패딩된 R 채널에서 뽑은 3x3 패치가 $P_R$ 이라고 하자.
        $$
        P_R = \begin{bmatrix} p_{11} & p_{12} & p_{13} \\ p_{21} & p_{22} & p_{23} \\ p_{31} & p_{32} & p_{33} \end{bmatrix}
        $$

2.  **원소별 곱셈**: 이 패치 $P_R$랑 아까 정의한 커널 $K$랑 같은 위치에 있는 숫자끼리 죄다 곱한다.
    $$
    \text{곱셈결과}_{R}[m,n] = P_R[m,n] \times K[m,n]
    $$
    * 예를 들어, $P_R$의 (0,0) 위치 값이랑 $K$의 (0,0) 위치 값을 곱하고, $P_R$의 (0,1)이랑 $K$의 (0,1) 곱하고... 이렇게 9개 다 곱하는 거임. 그럼 3x3짜리 '곱셈결과' 행렬이 하나 나오겠지.

3.  **싹 다 더하기**: 위에서 나온 '곱셈결과' 행렬의 원소 9개를 전부 더한다.
    $$
    \text{새 R값}_{\text{out}}[y_{out}, x_{out}] = \sum_{m=0}^{2}\sum_{n=0}^{2} \text{곱셈결과}_{R}[m,n]
    $$
    * 이 합산된 값이 바로 결과 이미지의 $(y_{out}, x_{out})$ 위치에 들어갈 새로운 R 채널 값이다!

4.  **G, B 채널도 똑같이**: 이 지랄을 G 채널 패치, B 채널 패치에도 똑같이 반복해서 새로운 G값, B값을 구한다. 그럼 결과 픽셀의 (R, G, B) 값이 다 나오는 거임.

5.  **값 범위 조절 (Clamping)**: 계산하다 보면 값이 255를 넘거나 0보다 작아질 수 있다. 이런 건 0~255 사이로 강제로 맞춰줘야 함 (`max(0, min(255, 값))`). 안 그러면 짤 색깔 터지거나 이상해진다.

## 9-5. 단계별 시각화
step9 을 실행하면, 10x10 에서 각 픽셀단위로 계산해서 이미지 바뀌는걸 시각화 해높음 

`matplotlib` 그림판으로는 두 개 띄워준다:
* **왼쪽 창**: 원본 컬러 이미지 (안 변함). 현재 커널이 어디쯤 작업하는지 초록색 네모로 표시됨.
* **오른쪽 창**: 필터링 결과 이미지가 한 픽셀 한 픽셀 채워지는 과정이 실시간으로 보임. 방금 계산 끝난 픽셀은 노란색 네모로 표시.

`plt.pause(0.2)` 같은 걸로 각 단계마다 0.2초씩 멈추니까 변화를 똑똑히 볼 수 있다.
만약 콘솔 출력이 너무 많아서 정신 사나우면 코드에서 `print_small_matrix` 부분 몇 개 주석 처리하고 보면 됨.

## 9-6. 마무리

컨볼루션 필터링이라는 게 별거 없다.

그냥 작은 행렬(커널) 가지고 큰 행렬(이미지 각 채널)을 for문으로 돌면서 matrix multiplication 하는 것이다. 

이 단순한 작업으로 블러도 만들고, 샤프닝도 하고, 엣지도 찾고 별별 마법을 다 부리는 거임.



# step10. HSV

## 10-1. what is HSV?

- H (Hue, 색상): 
    - '어떤 종류의 색인가?'를 나타냅니다. 
    - 우리가 흔히 말하는 빨강, 주황, 노랑, 초록, 파랑, 남색, 보라 같은 무지개색들을 생각하시면 됩니다. 
    - 보통 0도에서 360도 범위의 각도로 표현하며, 특정 값(예: 0도=빨강, 120도=초록, 240도=파랑)으로 나타냅니다. 
    - 이미지 처리에서는 보통 0~179 또는 0~255 범위로 스케일링해서 사용합니다.
- S (Saturation, 채도): 
    - '색상이 얼마나 선명하고 순수한가?'를 나타냅니다. 
    - 값이 높을수록 아주 쨍하고 순수한 색이 되고, 값이 낮을수록 해당 색에 회색빛이 많이 섞여 탁해지다가 0이 되면 완전히 무채색(회색조)이 됩니다. 
    - 물감에 흰색이나 회색 물감을 얼마나 섞었는지와 비슷하다고 생각할 수 있습니다. (님이 말씀하신 "빨~흑"보다는 "선명한 빨강 ~ 탁한 빨강(회색빛) ~ 완전한 회색/흰색"에 가깝습니다. Value 값에 따라 어두운 회색(검정)이 될 수도 있습니다.) 
    - 범위는 보통 0~1 또는 0~255입니다.
- V (Value, 명도/밝기): 
    - '색상이 얼마나 밝거나 어두운가?'를 나타냅니다. 
    - 명암이라고 하신 부분과 정확히 일치합니다. 
    - 값이 0이면 검은색이고, 값이 높을수록 해당 색상이 점점 밝아집니다. 
    - 범위는 보통 0~1 또는 0~255입니다.


## 10-2. RGB에서 HSV의 정보가 어떻게 저장되지?

따로 R,G,B 2차월 행렬에 HSV값에 대한 공간을 마련해서 저장하는게 아니라,\
각 픽셀의 (R, G, B) 값으로부터 변환 공식을 통해 계산된다.

이미지의 특정 픽셀 (y, x)의 RGB 값인 (R_yx, G_yx, B_yx)를 가져와서, 수학적 변환 함수에 넣으면 해당 픽셀의 HSV 값인 (H_yx, S_yx, V_yx)가 나온다.

결론적으로,

- RGB 이미지는 matrix_r, matrix_g, matrix_b라는 3개의 2차원 행렬로 표현됩니다.
- 각 픽셀의 (R, G, B) 값을 변환하면 해당 픽셀의 (H, S, V) 값을 얻을 수 있습니다.
- 이 변환을 모든 픽셀에 대해 수행하면, 이미지 전체에 대한 matrix_h, matrix_s, matrix_v라는 새로운 3개의 2차원 행렬을 얻게 됩니다.

## 10-3. 언제 HSV를 씀?
색상 조절할 때 효과적이다.
1. matrix_h의 모든 값을 일괄적으로 변경하면 이미지 전체의 색조를 바꿀 수 있습니다 (예: 모든 빨간색 계열을 초록색 계열로).
2. matrix_s의 값을 조절하면 이미지의 채도를 높여 더 생생하게 만들거나, 낮춰서 흑백에 가깝게 만들 수 있습니다.
3. matrix_v의 값을 조절하면 이미지의 전체적인 밝기를 조절할 수 있습니다.

## 10-4. 코드 설명 

핵심 단계:
1. 컬러 이미지 로드 (R, G, B 각 채널을 2차원 행렬로 분리).
2. 각 픽셀의 (R, G, B) 값을 (H, S, V) 값으로 변환 (Python의 colorsys 모듈 활용).
    - colorsys는 R,G,B 및 H,S,V 값을 0.0 ~ 1.0 범위로 다룹니다. 그래서 0~255 범위의 픽셀 값을 0~1로 정규화했다가, 나중에 다시 0~255로 돌려야 합니다.
3. HSV 공간에서 H, S, 또는 V 값을 변경하여 효과 적용.
    - 예: Hue 값을 전체적으로 이동시켜 색조 변경.
    - 예: Saturation 값을 조절하여 채도 변경 (더 선명하게 또는 더 흐리게).
    - 예: Value 값을 조절하여 명도 변경 (더 밝게 또는 더 어둡게).
4. 변경된 (H, S, V) 값을 다시 (R, G, B) 값으로 변환.
5. 원본 이미지와 효과가 적용된 이미지를 시각화.


# step11. 이진화(binarization)

## 11-1. what 
이미지에서 특정 부분만 강조하거나 불필요한 부분을 제거하는 데 아주 유용하게 사용되는 기본적인 이미지 처리 기법

간단하게 말해서, 이미지를 오직 두 가지 색상, 보통 검은색과 흰색만으로 표현하도록 변환하는 과정입니다.

- 원본 이미지가 여러 단계의 회색조(Grayscale)를 가지고 있거나, 다양한 색상(Color)을 가지고 있을 때, 이진화를 거치면 각 픽셀은 딱 두 가지 값 중 하나만 갖게 됩니다. (예: 0 또는 255, 혹은 0 또는 1)
- 결과적으로 이미지가 마치 실루엣처럼 보이거나, 아주 대비가 강한 흑백 복사본처럼 변합니다. 중간 단계의 회색이 사라지는 거죠.

방법:
1. 임계값을 정한다.
2. 만약 픽셀의 밝기 값이 임계값보다 크면 → 해당 픽셀은 흰색 (예: 255)으로 바뀝니다.
3. 만약 픽셀의 밝기 값이 임계값보다 작거나 같으면 → 해당 픽셀은 검은색 (예: 0)으로 바뀝니다.

(픽셀 입력값을 P 
in
 , 출력값을 P 
out
 , 임계값을 T, 최대값을 MaxVal이라 할 때):
$$
P_{out} = \begin{cases} \text{MaxVal} & \text{if } P_{in} > T \ 0 & \text{if } P_{in} \le T \end{cases}
$$

## 11-2. why 
이진화 왜 쓸까?

1. 이미지 단순화: 수많은 색상 정보나 다양한 밝기 단계를 가진 복잡한 이미지를 단 두 가지 값(흑/백)으로 단순화합니다. 이렇게 하면 이후의 분석이나 처리가 훨씬 쉬워지고 빨라집니다.
2. 객체/배경 분리 (관심 영역 추출): 이게 바로 님이 말씀하신 "특정 부분 불필요한 부분 날릴 때 쓴다"는 점과 직결됩니다!
    - 만약 이미지에서 찾고 싶은 물체(관심 영역)가 배경보다 확연히 밝거나 어둡다면, 적절한 임계값을 설정해서 물체는 흰색으로, 배경은 검은색으로 (또는 그 반대로) 분리해낼 수 있습니다.
    - 예를 들어, 흰 종이에 검은색 글씨가 있다면, 임계값을 잘 조절해서 글씨 부분만 검은색으로, 종이 부분은 흰색으로 만들 수 있죠. (OpenCV에서는 보통 관심 객체를 흰색으로, 배경을 검은색으로 만듭니다.)
3. 특징 추출 용이: 단순화된 이진 이미지는 다음과 같은 작업에 유용합니다.
    - 모양 분석: 물체의 윤곽선, 면적, 길이 등을 분석하기 쉬워집니다.
    - 객체 개수 세기: 분리된 흰색 (또는 검은색) 덩어리(connected components)의 개수를 세어 객체의 수를 파악할 수 있습니다.
    - 광학 문자 인식 (OCR): 글자를 인식하기 전에 이진화를 통해 글자와 배경을 명확히 분리합니다.
    - 마스크(Mask) 생성: 특정 영역만 처리하고 싶을 때, 이진화된 이미지를 마스크로 사용하여 원하는 부분에만 연산을 적용할 수 있습니다.

## 11-3. 임계값 정하는 법 
임계값 정하는 게 수동으로 하는 법도 있지만, 이미지의 히스토그램(밝기 분포)를 분석으로 자동으로 분석해서 임계값 결정하는 알고리즘이 있다.

## 11-4. 이진화 적용하는 프로세스 
```
컬러 이미지 → 흑백 이미지 변환 → 이진화 적용 → 흑백 이진 이미지 결과
```

이진화의 주된 목적이 형태, 윤곽선, 영역 분리 등 빛의 강도 차이에 기반한 정보를 추출하는 것이기 때문에, 색상 정보를 단일 밝기 정보로 통합한 후 처리하는 것이 훨씬 보편적이고 효과적인 방법

